<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sloty</title>
    <style>
        /*
 * Optimized CSS for smooth slot machine performance
 * Removed heavy background animations and effects
 */

* {
    box-sizing: border-box;
}

:root {
    --item-height: 100px;
}

body {
    margin: 0;
    font-family: Arial, sans-serif;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    background: linear-gradient(135deg, #4a148c 0%, #6a1b9a 50%, #7b1fa2 100%);
    position: relative;
    overflow: hidden;
}

/*
 * Game info panel
 */
.game-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    color: white;
    font-size: 18px;
}

.bet-controls {
    display: flex;
    align-items: center;
    gap: 10px;
}

.bet-controls label {
    color: white;
}

.bet-controls input {
    width: 80px;
    padding: 5px;
    font-size: 16px;
}

.balance {
    background: linear-gradient(45deg, #f39c12, #e67e22);
    padding: 10px 20px;
    border-radius: 5px;
    font-weight: bold;
    color: white;
}

/*
 * Buttons
 */
.start-button {
    display: block;
    margin: 1em auto;
    padding: 15px 40px;
    background: linear-gradient(45deg, #27ae60, #2ecc71);
    color: white;
    border: none;
    border-radius: 5px;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.start-button:hover:not(:disabled) {
    background: linear-gradient(45deg, #2ecc71, #27ae60);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

.start-button:disabled {
    background: #7f8c8d;
    cursor: not-allowed;
    transform: none;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.reel-controls {
    display: flex;
    justify-content: space-around;
    padding: 10px;
}

.reel-buttons {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.reel-button {
    padding: 10px 15px;
    min-width: 80px;
    background-color: #e74c3c;
    color: white;
    border: none;
    border-radius: 5px;
    font-size: 14px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.2s ease;
}

.reel-button:hover:not(:disabled) {
    background-color: #c0392b;
    transform: translateY(-2px);
}

.reel-button:disabled {
    background-color: #7f8c8d;
    cursor: not-allowed;
    transform: none;
}

/*
 * Payline indicator - simplified
 */
.payline {
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, 
        rgba(255,0,0,0) 0%,
        rgba(255,0,0,0.8) 20%,
        rgba(255,0,0,0.8) 80%,
        rgba(255,0,0,0) 100%
    );
    transform: translateY(-1px);
    z-index: 15;
}

/*
 * Win message - simplified
 */
.win-message {
    position: fixed;
    top: 5%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(45deg, #f1c40f, #f39c12);
    color: #2c3e50;
    padding: 20px 40px;
    border-radius: 10px;
    font-size: 24px;
    font-weight: bold;
    z-index: 1000;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    display: none;
    max-width: 90vw;
    text-align: center;
}
/*
 * Main container - simplified
 */
#container {
    background-color: rgba(4, 9, 15, 0.95);
    padding: 50px;
    position: relative;
    width: fit-content;
    margin: auto;
    border-radius: 15px;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
}

/*
 * Window styling - optimized
 */
.window {
    position: relative;
    overflow: hidden;
    height: calc(3 * var(--item-height));
}

.window::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 6px;
    background: linear-gradient(to bottom, rgba(0, 0, 0, 0.4), transparent);
    z-index: 10;
}

.window::after {
    content: "";
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 6px;
    background: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.4));
    z-index: 10;
}

.window-border {
    padding: 5px;
    background: linear-gradient(to bottom, #fcf8ad, #f8f3cd, #f9e13d);
    box-shadow: 0 6px 4px -5px #eca654 inset;
    position: relative;
    z-index: 1;
}

.window-border-container {
    position: relative;
    margin-bottom: 20px;
}

/*
 * Reels and icon styling - performance optimized
 */
.icon {
    width: 80px;
    height: var(--item-height);
    display: block;
    position: relative;
}

.outer-col {
    overflow-y: hidden;
    width: 100px;
    float: left;
    background: linear-gradient(to bottom, #16013c, #741a5e, #430155, #16013c);
    height: calc(var(--item-height) * 3);
}

.outer-spacer {
    width: 8px;
    height: 100%;
    float: left;
    border-right: 1px solid rgba(247, 206, 108, 0.15);
    background-color: #893802;
}

.col {
    padding: 0 10px;
    will-change: transform;
    transform: translateY(calc(-100% + var(--item-height) * 3));
    /* Optimized for hardware acceleration */
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
    perspective: 1000px;
    -webkit-perspective: 1000px;
}

.col img {
    width: 100%;
    height: auto;
    margin: 10px 0;
    position: relative;
    z-index: 3;
    /* Optimize images for animation */
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
}

/* Simplified shadow effect - much lighter on performance */
.col .icon::after {
    content: "";
    position: absolute;
    top: 50%;
    left: 50%;
    width: 60px;
    height: 60px;
    background: radial-gradient(circle, rgba(0,0,0,0.3) 0%, transparent 70%);
    transform: translate(-50%, -50%);
    z-index: 2;
    border-radius: 50%;
}
    </style>
    <script defer>
        // Simple Sound Manager using Web Audio API (no external files)
        const Sound = (() => {
            let ctx = null;
            const ensureCtx = () => {
                if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (ctx.state === 'suspended') ctx.resume();
                return ctx;
            };

            const playTone = ({ freq = 440, type = 'sine', duration = 120, gain = 0.05, startFreq, endFreq }) => {
                const ac = ensureCtx();
                const osc = ac.createOscillator();
                const g = ac.createGain();
                osc.type = type;
                const now = ac.currentTime;
                if (startFreq && endFreq) {
                    osc.frequency.setValueAtTime(startFreq, now);
                    // Use an exponential ramp for a pleasing glide
                    const endTime = now + duration / 1000;
                    osc.frequency.exponentialRampToValueAtTime(Math.max(1, endFreq), endTime);
                } else {
                    osc.frequency.setValueAtTime(freq, now);
                }
                g.gain.setValueAtTime(Math.max(0.0005, gain), now);
                // Quick decay envelope
                g.gain.exponentialRampToValueAtTime(0.0001, now + duration / 1000);
                osc.connect(g);
                g.connect(ac.destination);
                osc.start(now);
                osc.stop(now + duration / 1000 + 0.02);
            };

            const playSpinStart = () => {
                // Short whoosh: downward sawtooth glide
                playTone({ type: 'sawtooth', startFreq: 900, endFreq: 220, duration: 280, gain: 0.06 });
            };

            const playReelStop = () => {
                // Snappy tick
                playTone({ type: 'square', freq: 650, duration: 70, gain: 0.05 });
            };

            const playWin = () => {
                // Quick triumphant arpeggio
                const ac = ensureCtx();
                const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
                const start = ac.currentTime;
                notes.forEach((f, i) => {
                    setTimeout(() => playTone({ type: 'triangle', freq: f, duration: 140, gain: 0.05 }), i * 90);
                });
            };

            const playLose = () => {
                // Soft thud
                playTone({ type: 'sine', freq: 140, duration: 160, gain: 0.04 });
            };

            return { playSpinStart, playReelStop, playWin, playLose, _ensureCtx: ensureCtx };
        })();
        // Reel configurations based on the specification
const REEL_CONFIGS = {
    reel1: [
        'cherry', 'banana', 'cherry', 'orange', 'orange', 'orange', 'lucky_seven',
        'banana', 'watermelon', 'watermelon', 'tripple_bar', 'tripple_bar', 'tripple_bar',
        'cherry', 'cherry', 'watermelon', 'banana', 'banana', 'banana', 'orange', 'orange'
    ],
    reel2: [
        'orange', 'orange', 'orange', 'lucky_seven', 'cherry', 'banana', 'cherry',
        'orange', 'orange', 'lucky_seven', 'watermelon', 'watermelon', 'banana',
        'tripple_bar', 'tripple_bar', 'orange', 'cherry', 'cherry', 'banana', 'banana', 'banana'
    ],
    reel3: [
        'tripple_bar', 'banana', 'banana', 'orange', 'orange', 'orange', 'cherry',
        'banana', 'cherry', 'tripple_bar', 'orange', 'orange', 'watermelon',
        'banana', 'banana', 'orange', 'watermelon', 'tripple_bar', 'cherry', 'lucky_seven', 'cherry'
    ]
};

// Timing configuration
const REEL_STOP_INTERVAL = 3000; // 3 seconds between reel stops
const REEL_STOP_TIMES = [3000, 6000, 9000]; // Auto-stop times for each reel
const SPIN_SPEED = 25; // Constant spin speed
const SNAP_DURATION = 200; // Snap animation duration in ms
const INITIAL_SPIN_SPEED = 25; // Initial spin speed

/**
 * Win payout table
 */
const PAYOUTS = {
    cherry: { 1: 2, 2: 5, 3: 7 },
    banana: { 3: 10 },
    watermelon: { 3: 20 },
    tripple_bar: { 3: 40 },
    lucky_seven: { 3: 100 },
    other: { 3: 5 }
};

var cols;
var stopButtons = [];
var gameState = {
    balance: 100,
    isSpinning: false,
    spinStartTime: 0,
    reels: []
};
var animationId = null;

window.addEventListener('DOMContentLoaded', function(event) {
    cols = document.querySelectorAll('.col');
    
    // Initialize physics state for each reel
    for (let i = 0; i < cols.length; i++) {
        gameState.reels.push({
            position: 0,
            stopped: false,
            stopTime: null, // When this reel should stop
            isSnapping: false,
            element: cols[i], // Cache the DOM element
            canBeStoppedManually: false,
            reel_speed: INITIAL_SPIN_SPEED + 0.1 * INITIAL_SPIN_SPEED
        });
    }

    setInitialItems();
    initalizeStopButtons();
    updateBalance();
    
    // Add CSS optimization
    cols.forEach(col => {
        col.style.transition = 'none';
        col.style.willChange = 'transform';
    });
});

function setInitialItems() {
    for (let i = 0; i < cols.length; ++i) {
        let col = cols[i];
        const reelConfig = REEL_CONFIGS[`reel${i + 1}`];
        let elms = '';

        // Create 4 repetitions for smooth wrapping
        for (let rep = 0; rep < 4; rep++) {
            for (let x = 0; x < reelConfig.length; x++) {
                let icon = reelConfig[x];
                let item = '<div class="icon" data-item="' + icon + '"><img src="items/' + icon + '.png"></div>';
                elms += item;
            }
        }

        col.innerHTML = elms;
        gameState.reels[i].position = reelConfig.length * 100 * 2; // Start in middle section
    }
    
    updateReelPositions();
}

/**
 * Start spinning with predictable timing
 */
function spin(elem) {
    if (gameState.isSpinning) return;
    
    // Check bet amount
    const betAmount = parseInt(document.getElementById('betAmount').value);
    if (betAmount > gameState.balance || betAmount < 1) {
        alert('Invalid bet amount!');
        return;
    }
    
    // Deduct bet
    gameState.balance -= betAmount;
    updateBalance();
    
    // Disable spin button
    elem.setAttribute('disabled', true);
    gameState.isSpinning = true;
    gameState.spinStartTime = performance.now();

    // Reset all reels
    gameState.reels.forEach((reel, i) => {
        reel.stopped = false;
        reel.stopTime = null;
        reel.isSnapping = false;
        reel.canBeStoppedManually = (i === 0); // Only first reel can be stopped initially
        reel.element.style.transition = 'none';
    });

    // Set auto-stop times
    gameState.reels[0].stopTime = gameState.spinStartTime + REEL_STOP_TIMES[0];
    gameState.reels[1].stopTime = gameState.spinStartTime + REEL_STOP_TIMES[1];
    gameState.reels[2].stopTime = gameState.spinStartTime + REEL_STOP_TIMES[2];

    updateStopButtonStates();
    
    // Prime audio on user interaction and play spin sound
    try { Sound._ensureCtx(); Sound.playSpinStart(); } catch (e) {}

    // Start animation
    animationId = requestAnimationFrame(animateReels);
}

/**
 * Main animation loop with predictable timing
 */
function animateReels() {
    const now = performance.now();
    let allStopped = true;

    for (let i = 0; i < gameState.reels.length; i++) {
        const reel = gameState.reels[i];

        if (!reel.stopped && !reel.isSnapping) {
            allStopped = false;

            // Check if it's time to stop this reel
            if (now >= reel.stopTime) {
                stopReelSmooth(i);
            } else {
                // Calculate current speed using gradual deceleration
                const totalTime = REEL_STOP_TIMES[i]; // Total time for this reel
                const elapsedTime = now - gameState.spinStartTime;
                const timeLeft = totalTime - elapsedTime;
                
                // Apply your equation: v_initial * (time_left / total_time)
                const currentSpeed = reel.reel_speed;
                
                reel.position -= currentSpeed;
            }
        }
    }

    updateReelPositions();

    if (allStopped) {
        // Game finished
        gameState.isSpinning = false;
        document.querySelector('.start-button').removeAttribute('disabled');
        
        // Reset all stop buttons
        stopButtons.forEach(btn => {
            btn.removeAttribute('disabled');
            btn.classList.remove('disabled-button');
        });

        setTimeout(() => {
            checkWinConditions();
        }, 200);
    } else {
        animationId = requestAnimationFrame(animateReels);
    }
}

/**
 * Smoothly stop a reel with snap-to-symbol
 */
function stopReelSmooth(reelIndex) {
    const reel = gameState.reels[reelIndex];
    if (reel.stopped || reel.isSnapping) return;

    reel.isSnapping = true;
    
    // Disable THIS reel's button immediately since it's stopping
    reel.canBeStoppedManually = false;
    
    // Enable next reel's stop button immediately (no delay!)
    if (reelIndex < gameState.reels.length - 1) {
        gameState.reels[reelIndex + 1].canBeStoppedManually = true;
    }
    
    // Update button states for both changes
    updateStopButtonStates();
    
    // Find nearest symbol position
    const reelConfig = REEL_CONFIGS[`reel${reelIndex + 1}`];
    const itemHeight = 100;
    const symbolIndex = Math.round(reel.position / itemHeight);
    const targetPosition = symbolIndex * itemHeight;
    
    // Smooth snap animation
    const startPos = reel.position;
    const distance = targetPosition - startPos;
    const startTime = performance.now();
    
    function snapAnimation(time) {
        let progress = Math.min(1, (time - startTime) / SNAP_DURATION);
        // Smooth easing out
        progress = 1 - Math.pow(1 - progress, 3);
        
        reel.position = startPos + distance * progress;
        updateSingleReelPosition(reelIndex);
        
        if (progress < 1) {
            requestAnimationFrame(snapAnimation);
        } else {
            // Reel fully stopped
            reel.stopped = true;
            reel.isSnapping = false;
            // Play reel stop tick
            try { Sound.playReelStop(); } catch (e) {}
        }
    }
    
    requestAnimationFrame(snapAnimation);
}

/**
 * Update stop button states based on game rules
 */
function updateStopButtonStates() {
    stopButtons.forEach((button, i) => {
        if (gameState.reels[i].canBeStoppedManually && !gameState.reels[i].stopped) {
            button.removeAttribute('disabled');
            button.classList.remove('disabled-button');
        } else {
            button.setAttribute('disabled', true);
            button.classList.add('disabled-button');
        }
    });
}

/**
 * Manual stop function - called when user presses stop button
 */
function stopReel(reelIndex) {
    if (!gameState.isSpinning || gameState.reels[reelIndex].stopped || !gameState.reels[reelIndex].canBeStoppedManually) {
        return;
    }
    
    const now = performance.now();
    
    // Stop this reel immediately
    gameState.reels[reelIndex].stopTime = now;
    
    // Update stop times for remaining reels (3 seconds from now)
    for (let i = reelIndex + 1; i < gameState.reels.length; i++) {
        if (!gameState.reels[i].stopped) {
            gameState.reels[i].stopTime = now + (REEL_STOP_INTERVAL * (i - reelIndex));
        }
    }
    
    // Disable this button immediately
    gameState.reels[reelIndex].canBeStoppedManually = false;
    updateStopButtonStates();
}

/**
 * Hardware-accelerated position updates
 */
function updateReelPositions() {
    for (let i = 0; i < cols.length; i++) {
        updateSingleReelPosition(i);
    }
}

function updateSingleReelPosition(i) {
    const reel = gameState.reels[i];
    const reelConfig = REEL_CONFIGS[`reel${i + 1}`];
    const sectionHeight = reelConfig.length * 100;
    
    let position = reel.position;
    
    // Handle smooth wrapping
    position = position % (sectionHeight * 4);
    if (position < 0) position += sectionHeight * 4;
    
    // Keep in visible range
    if (position < sectionHeight) {
        position += sectionHeight * 2;
        reel.position = position;
    } else if (position >= sectionHeight * 3) {
        position -= sectionHeight * 2;
        reel.position = position;
    }

    const translateY = -position + (2 * 100);
    reel.element.style.transform = `translate3d(0, ${translateY}px, 0)`;
}

/**
 * Get symbols on payline
 */
function getCurrentPaylineSymbols() {
    const symbols = [];
    
    for (let i = 0; i < 3; i++) {
        const reel = gameState.reels[i];
        const reelConfig = REEL_CONFIGS[`reel${i + 1}`];
        
        const sectionHeight = reelConfig.length * 100;
        const normalizedPosition = ((reel.position % sectionHeight) + sectionHeight) % sectionHeight;
        const middleIndex = Math.round(normalizedPosition / 100);
        
        const actualIndex = (middleIndex - 1 + reelConfig.length) % reelConfig.length;
        const symbolName = reelConfig[actualIndex];
        symbols.push(symbolName);
    }
    
    return symbols;
}

/**
 * Check win conditions and update balance
 */
function checkWinConditions() {
    const symbols = getCurrentPaylineSymbols();
    const betAmount = parseInt(document.getElementById('betAmount').value);
    let winAmount = 0;
    let winMessage = '';
    
    // Count cherries anywhere
    const cherryCount = symbols.filter(s => s === 'cherry').length;
    
    // Check for cherry wins
    if (cherryCount > 0) {
        winAmount = PAYOUTS.cherry[cherryCount] || PAYOUTS.cherry[3];
        winMessage = `${cherryCount} Cherry${cherryCount > 1 ? 'ies' : ''} - You win ${winAmount} credits!`;
    }
    
    // Check for three of a kind
    if (symbols[0] === symbols[1] && symbols[1] === symbols[2]) {
        const symbol = symbols[0];
        if (symbol === 'cherry') {
            // Already handled above
        } else if (symbol === 'orange') {
            winAmount = 5;
            winMessage = '3 Oranges - You win 5 credits!';
        } else if (symbol === 'banana') {
            winAmount = 10;
            winMessage = '3 Bananas - You win 10 credits!';
        } else if (symbol === 'watermelon') {
            winAmount = 20;
            winMessage = '3 Watermelons - You win 20 credits!';
        } else if (symbol === 'tripple_bar') {
            winAmount = 40;
            winMessage = '3 Triple Bars - You win 40 credits!';
        } else if (symbol === 'lucky_seven') {
            winAmount = 100;
            winMessage = '3 Sevens - You win 100 credits!';
        }
    }
    
    winAmount = Math.floor(winAmount * (betAmount / 5));
    
    if (winAmount > 0) {
        gameState.balance += winAmount;
        updateBalance();
        showWinMessage(winMessage);
        try { Sound.playWin(); } catch (e) {}
    } else {
        // Subtle feedback on loss
        try { Sound.playLose(); } catch (e) {}
    }
}

function updateBalance() {
    document.getElementById('balance').textContent = gameState.balance;
}

function showWinMessage(message) {
    const winMessageElement = document.getElementById('winMessage');
    if (winMessageElement) {
        winMessageElement.textContent = message;
        winMessageElement.style.display = 'block';
       
        setTimeout(() => {
            winMessageElement.style.display = 'none';
        }, 1500);
    }
}

function initalizeStopButtons() {
    for(var i = 1; i <= cols.length; i++) {
        const button = document.getElementById('sp' + i);
        stopButtons.push(button);
        
        button.addEventListener('click', (function(reelIndex) {
            return function() {
                stopReel(reelIndex);
            }
        })(i - 1));
    }
}
    </script>
</head>
<body>

<div id="container">
    <!-- Game Info Panel -->
    <!-- shows bet controls and balance -->
    <div class="game-info">
        <div class="bet-controls">
            <label for="betAmount">Bet:</label>
            <input type="number" id="betAmount" min="1" max="100" value="10">
        </div>
        <div class="balance">Balance: $<span id="balance">100</span></div>
    </div>

    <div class="window-border-container">
        <div class="window-border">
            <div class="window">
                <!-- payline indicates the visible middle row -->
                <div class="payline"></div>
                <div class="outer-spacer"></div>

                <!-- each outer-col contains one reel (col) -->
                <div class="outer-col">
                    <div class="col"></div>
                </div>
                <div class="outer-spacer"></div>
                <div class="outer-col">
                    <div class="col"></div>
                </div>
                <div class="outer-spacer"></div>
                <div class="outer-col">
                    <div class="col"></div>
                </div>
                <div class="outer-spacer"></div>
            </div>

        <!-- stop buttons for each reel -->
        <div class="reel-controls">
            <div class="reel-buttons">
                <button id="sp1" class="reel-button">Stop</button>
            </div>
            <div class="reel-buttons">
                <button id="sp2" class="reel-button">Stop</button>
            </div>
            <div class="reel-buttons">
                <button id="sp3" class="reel-button">Stop</button>
            </div>
        </div>
    </div>

    <!-- main spin control -->
    <input type="button" onclick="spin(this)" class="start-button" value="Spin"/>
    
    <!-- shows win text briefly -->
    <div class="win-message" id="winMessage"></div>
</div>

</body>
</html>
